generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Organization {
  id        String   @id @default(uuid())
  name      String
  users     User[]
  createdAt DateTime @default(now())
}

// Better Auth user table - extended with org relationship
model User {
  id             String        @id @default(uuid())
  email          String        @unique
  name           String
  emailVerified  Boolean       @default(false)
  image          String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Our custom fields
  role           String        @default("member")
  orgId          String?
  org            Organization? @relation(fields: [orgId], references: [id], onDelete: Cascade)
  lastActivityAt DateTime?

  // Audit fields
  createdBy      String?
  createdByUser  User?         @relation("UserCreatedBy", fields: [createdBy], references: [id], onDelete: SetNull)
  updatedBy      String?
  updatedByUser  User?         @relation("UserUpdatedBy", fields: [updatedBy], references: [id], onDelete: SetNull)
  deletedBy      String?
  deletedByUser  User?         @relation("UserDeletedBy", fields: [deletedBy], references: [id], onDelete: SetNull)
  deletedAt      DateTime?

  // Better Auth relations
  sessions Session[]
  accounts Account[]

  // Audit relations (users created/updated/deleted by this user)
  usersCreated User[] @relation("UserCreatedBy")
  usersUpdated User[] @relation("UserUpdatedBy")
  usersDeleted User[] @relation("UserDeletedBy")

  @@index([orgId])
  @@index([createdBy])
  @@index([deletedAt])
}

// Better Auth required tables
model Session {
  id        String   @id @default(uuid())
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                    String    @id @default(uuid())
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
}

model Verification {
  id         String   @id @default(uuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

// Transactional Outbox Pattern for reliable event processing
model OutboxEvent {
  id          String   @id @default(uuid())
  aggregateId String   // The ID of the entity (e.g., userId, orgId)
  eventType   String   // Event name (e.g., "user.created", "user.updated")
  payload     String   // JSON payload with event data
  processed   Boolean  @default(false)
  processedAt DateTime?
  attempts    Int      @default(0)
  lastError   String?
  createdAt   DateTime @default(now())

  @@index([processed, createdAt])
  @@index([eventType, processed])
}

// Tracks digest batch runs for idempotency
model DigestBatch {
  id              String   @id @default(uuid())
  idempotencyKey  String?  @unique // Optional idempotency key from request
  userCount       Int      // Number of users the digest was sent to
  status          String   // "completed" or "failed"
  createdAt       DateTime @default(now())

  @@index([createdAt])
}

// General audit trail for user and system actions
model AuditLog {
  id        String   @id @default(uuid())
  actor     String   // User ID or "system" for automated actions
  action    String   // Action performed (e.g., "welcome_email_sent", "digest_email_sent")
  targetId  String?  // ID of the affected entity (e.g., user ID who received email)
  metadata  String?  // JSON string with additional context
  createdAt DateTime @default(now())

  @@index([actor, createdAt])
  @@index([action, createdAt])
  @@index([targetId])
}
